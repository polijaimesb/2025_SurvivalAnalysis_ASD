This script is to identify the polypharmacy events, the duration of the
polypharmacy and monotherapy events, according with the definition of
similar definitions of overlapping period (Spencer et al.), with two or
more medications overlapping during a period of 30 days.

    library(dplyr)
    library(DescTools)
    library(AdhereR)
    library(ggplot2) 
    library(RColorBrewer)
    library(data.table)
    library(lubridate)
    library(stringr)
    library(tidyr)

# Files

We will use the claims prescriptions from the patients who have a
diagnosed of metabolic syndrome related conditions at some point after
the first psychotropic medication.

    #Ages 2 to 64 yo - metabolic syndrome (pharmacotherapy and ABA)
    claims_prescriptions <- fread("Y:/Paula/Files_finish/NewFiles/2to64/030625_PharmacotherapyAndABA_MetabolicSyndrome_SurvivalAnalysis.csv") %>% 
      select(pat_id, from_dt_claim, month_id, dayssup, quan, medication, route, usc_name) %>% 
      mutate(
        duration = from_dt_claim + dayssup
      ) %>% 
      arrange(pat_id, from_dt_claim)

Number of patients before only including “Oral” as route.

    length(unique(claims_prescriptions$pat_id))

Number of claims before only including “Oral” as route.

    nrow(claims_prescriptions)

For the unification of the DDD and other definitions for aim 2, we will
keep only the prescription with “Oral” as a route.

    claims_prescriptions <- claims_prescriptions %>% 
      filter(route == "ORAL")

Number of patients after only including “Oral” as route.

    length(unique(claims_prescriptions$pat_id))

Number of claims after only including “Oral” as route.

    nrow(claims_prescriptions)

# Functions

There are 3 different functions used to identify the polypharmacy
monotherapy events. `medication_events` to identify the medications
events from the prescriptions. This process occurs for every medication
prescribed to each patient. `find_overlaps` identify the possible
combinations of medication events that are overlapping. In that
function, we are interested in find any pair of combination that is
overlapping without worry about the number of days ovelapping.
`merge_episodes_function` merges the polypharmacy/monotherapy pairs of
medications that are overlapping, or have a gap less or equal than 30
days. We realized that for monotherapy events, 30 days of a gap is not
adequate. We decided to do it as 1 day only. We were using
`compute.treatment.episodes` before but it was not returning the desired
results.

    #To identify medication events
    medication_events <- function(each_pat_id, claims_df){
      
      onePatient_df <- claims_df %>% 
        filter(pat_id == each_pat_id) %>%
        arrange(pat_id, from_dt_claim)
      
      medications_prescribed <- onePatient_df %>% 
        select(medication) %>% 
        unique %>% 
        unlist 
        
        cont = 1 
        
      for(med in medications_prescribed){
        medication_onePatient_df <- onePatient_df %>% 
          filter(medication == med) %>% 
          mutate(from_dt_claim = as.Date(from_dt_claim, "%Y-%m-%d")) %>% 
          select(pat_id, from_dt_claim, dayssup, medication, daily)
        
        colnames(medication_onePatient_df) <- c("PATIENT_ID", "DATE", "DURATION", "CATEGORY", "PERDAY")
      
      
        medication_onePatient_df <- medication_onePatient_df %>% 
          mutate(DATE  = as.Date(DATE, "%Y-%m-%d"))
      
      
        event_med <- compute.treatment.episodes(
          data = medication_onePatient_df,
          ID.colname = "PATIENT_ID",
          event.date.colname = "DATE",
          event.daily.dose.colname = "PERDAY",
          event.duration.colname = "DURATION", 
          medication.class.colname = "CATEGORY", 
          carry.only.for.same.medication = FALSE,
          carryover.within.obs.window = FALSE,
          maximum.permissible.gap = 30, #becuase this is per med no between meds
          maximum.permissible.gap.unit = "days",
          followup.window.start = 0,
          followup.window.start.unit = "days",
          followup.window.duration = 365*20,
          date.format = "%Y-%m-%d"
      )
      
        event_med <- event_med %>%
          mutate(medication = med)
      
        
        assign(paste0("event_meds",cont),event_med)
        
        cont = cont +1 
      }
      
      df_names <- paste0("event_meds",1:(cont-1))
      df_list <- mget(df_names, inherits =  FALSE)
      
      #For all the medications 
      event_meds_all <- bind_rows(df_list) %>% 
      arrange(episode.start)
      
      
      return(bind_rows(event_meds_all))
    }

    # Function to detect unique medication overlaps
    find_overlaps <- function(each_pat_id, all_events) {
      
      df <- all_events %>% 
        filter(PATIENT_ID == each_pat_id) %>%
        arrange(episode.start)  # Ensure events are sorted

      overlap_results <- list()
      is_overlapping <- rep(FALSE, nrow(df))
      
      df <- df %>% 
        mutate(is_overlapping = is_overlapping)
      
      # If only one row exists, directly append it without merging
      if (nrow(df) == 1) {
        overlap_results <- append(overlap_results, list(
              data.frame(
                patientID = df$PATIENT_ID[1],
                medication1 = df$medication[1],
                medication2 = "",
                overlap_start = df$episode.start[1],
                overlap_end = df$episode.end[1]
              ))
        )
        
      }else{

        # overlap_last <- FALSE
        for (i in 1:(nrow(df) - 1)) {
          # overlap <- FALSE
          for (j in (i + 1):nrow(df)) {# Compare each event with subsequent ones
            start_overlap <- max(df$episode.start[i], df$episode.start[j])
            end_overlap <- min(df$episode.end[i], df$episode.end[j])
            
            # print(start_overlap)
            # print(end_overlap)
            # 
      
            if (start_overlap < end_overlap) {  # Check if there's an overlap
              # print(end_overlap)
              overlap_results <- append(overlap_results, list(
                data.frame(
                  patientID = df$PATIENT_ID[i],
                  medication1 = df$medication[i],
                  medication2 = df$medication[j],
                  overlap_start = start_overlap,
                  overlap_end = end_overlap
                )
              ))
              
              # overlap <- TRUE
              # if(j == nrow(df)){
              #   overlap_last <- TRUE
              # }
              
              df$is_overlapping[i] <- TRUE
              df$is_overlapping[j] <- TRUE
              #overlap_list[j] <- TRUE
              
            }
            
          }
          
          all_events <- bind_rows(overlap_results)
          
        #   if(overlap == FALSE & !is.null(all_events)){ #& !(df$episode.start[i] %in% all_events$overlap_start)){
        #     overlap_results <- append(overlap_results, list(
        #         data.frame(
        #           patientID = df$PATIENT_ID[i],
        #           medication1 = df$medication[i],
        #           medication2 = "",
        #           overlap_start = df$episode.start[i],
        #           overlap_end = df$episode.end[i]
        #         )
        #       ))
        # 
        #   }
        # }   
        #   if(overlap_last == FALSE){
        #     overlap_results <- append(overlap_results, list(
        #       data.frame(
        #       patientID = df$PATIENT_ID[j],
        #       medication1 = df$medication[j],
        #       medication2 = "",
        #       overlap_start = df$episode.start[j],
        #       overlap_end = df$episode.end[j]
        #       )
        #     ))            
        #   }
          
        }
          df_NonOverlap <- df %>% 
            filter(is_overlapping == FALSE) %>% 
            select(-is_overlapping) %>% 
            mutate(
              patientID = PATIENT_ID, 
              medication1 = medication, 
              medication2 = "",
              overlap_start = episode.start, 
              overlap_end = episode.end
            ) %>% 
            select(-PATIENT_ID, -medication, -episode.start, -episode.end)
          
          overlap_results <- bind_rows(overlap_results, df_NonOverlap) %>% 
            arrange(overlap_start)
        
      }

      return(bind_rows(overlap_results))  # Combine results into a dataframe
    }

    # Function to merge overlapping or closely spaced episodes within the same med_group
    merge_episodes_function <- function(df, gap_threshold = 1) { #gap_threshold = 30
      df <- df %>%
        arrange(patientID, med_group, overlap_start, overlap_end) # Sort by patient, group, and dates

      merged_episodes <- list()  # Empty list to store merged results

      for (patient in unique(df$patientID)) {
        patient_data <- df %>% filter(patientID == patient)  # Extract data for each patient

        # If only one row exists, directly append it without merging
        if (nrow(patient_data) == 1) {
          merged_episodes <- append(merged_episodes, list(patient_data))
          next  # Skip merging logic and move to next patient
        }

        merged_patient_data <- list()  # Store merged periods for the patient
        current_start <- patient_data$overlap_start[1]
        current_end <- patient_data$overlap_end[1]
        current_medications <- unique(unlist(strsplit(patient_data$medication[1], ",")))
        current_med_group <- patient_data$med_group[1]  # Track the medication group

        for (i in 2:nrow(patient_data)) {
          next_start <- patient_data$overlap_start[i]
          next_end <- patient_data$overlap_end[i]
          next_medications <- unique(unlist(strsplit(patient_data$medication[i], ",")))
          next_med_group <- patient_data$med_group[i]  # Track the next medication group

          # Check if next episode belongs to the same group and overlaps or is within the gap threshold
          if ((next_start <= current_end | as.numeric(next_start - current_end) <= gap_threshold) &
              current_med_group == next_med_group) {
            # Merge episodes by updating the end date and adding medications
            current_end <- max(current_end, next_end)
            current_medications <- unique(c(current_medications, next_medications))
          } else {
            # Save the merged episode
            merged_patient_data <- append(merged_patient_data, list(
              data.frame(
                patientID = patient,
                med_group = current_med_group,
                overlap_start = current_start,
                overlap_end = current_end,
                duration = as.numeric(current_end - current_start),
                medication = paste(sort(current_medications), collapse = ", ")
              )
            ))
            # Start a new episode
            current_start <- next_start
            current_end <- next_end
            current_medications <- next_medications
            current_med_group <- next_med_group  # Update group tracking
          }
        }

        # Save the last merged episode
        merged_patient_data <- append(merged_patient_data, list(
          data.frame(
            patientID = patient,
            med_group = current_med_group,
            overlap_start = current_start,
            overlap_end = current_end,
            duration = as.numeric(current_end - current_start),
            medication = paste(sort(current_medications), collapse = ", ")
          )
        ))

        merged_episodes <- append(merged_episodes, merged_patient_data)
      }

      return(bind_rows(merged_episodes))  # Combine all merged episodes into a dataframe
    }

# Identification of polypharmacy/monotherapy

Once we run the functions, we will filter the records with less than 1
as day of supply, and pass the dataset to the different functions.

    claims_prescriptions <- claims_prescriptions %>% 
      filter(dayssup >= 1 & quan >= 1 ) %>% 
      mutate(daily = quan/dayssup)

    PatientID <- claims_prescriptions %>% 
      select(pat_id) %>% 
      unique %>% 
      unlist

    overlapping_period <- 30

    start.time <- Sys.time()

    event_meds_all <- bind_rows(lapply(PatientID, medication_events, claims_df = claims_prescriptions))

    # Run function to get medication overlaps
    overlap_data <- bind_rows(lapply(PatientID, find_overlaps, event_meds_all))

    overlap_data <- overlap_data %>%
      group_by(patientID) %>% 
      mutate(
        medication = if_else(medication2 != "", paste(medication1, medication2, sep = ","), medication1),
        duration = as.numeric(overlap_end - overlap_start),
        med_group = if_else(medication2 == "" | medication1 == "", "Monotherapy", "Polypharmacy"),
      ) %>% 
      ungroup()

    # Apply function to merge polypharmacy episodes
    merged_polypharmacy <- merge_episodes_function(overlap_data)

    # Classify them as polypharmacy, monotherapy or no polypharmacy 
    merged_polypharmacy <- merged_polypharmacy %>% 
      mutate(
        medication_name = medication
      ) %>% 
      group_by(patientID) %>% 
      rowwise() %>%
      mutate(
        episode.duration = as.numeric(overlap_end - overlap_start),
        med_count = length(unlist(strsplit(medication_name, ","))), 
        medication = case_when(
          med_count > 1 & episode.duration >= overlapping_period & med_group == "Polypharmacy" ~ paste0("Polypharmacy >= ", overlapping_period, " day(s)"),
          med_count > 1 & episode.duration < overlapping_period & med_group == "Polypharmacy" ~ paste0("Polypharmacy < ", overlapping_period, " day(s)"),
          med_group == "Monotherapy" ~ "Monotherapy"
        )
      ) %>% 
      ungroup() %>% 
      select(-duration,-med_group)

    #To match last column definitions 

    # colnames(merged_polypharmacy)[1] <- "PATIENT_ID"
    # colnames(merged_polypharmacy)[3] <- "episode.start"
    # colnames(merged_polypharmacy)[4] <- "episode.end"

    polypharmacy_Allevents <- merged_polypharmacy %>% 
      filter(episode.duration > 0)

    end.time <- Sys.time()

Time consumed.

    end.time - start.time
